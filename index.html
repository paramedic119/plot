<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700;900&family=Outfit:wght@400;700;900&display=swap"
        rel="stylesheet">
    <title>ãƒ©ã‚¤ãƒ‰å“è³ª çµ±åˆåˆ†æãƒ„ãƒ¼ãƒ«</title>
    <style>
        :root {
            --primary: #0ea5e9;
            --primary-glow: rgba(14, 165, 233, 0.4);
            --accent: #f43f5e;
            --road: #f59e0b;
            --safe: #10b981;
            --bg: #020617;
            --surface: rgba(15, 23, 42, 0.6);
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Noto Sans JP', 'Outfit', 'Inter', sans-serif;
            background: radial-gradient(circle at top right, #1e293b, #020617);
            background-attachment: fixed;
            color: var(--text-main);
            margin: 0;
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            line-height: 1.6;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-weight: 900;
            font-size: 2.5rem;
            margin: 0 0 30px 0;
            background: linear-gradient(135deg, #fff 0%, var(--primary) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -1px;
            text-transform: uppercase;
        }

        /* å…±é€šãƒœã‚¿ãƒ³ãƒ»ã‚³ãƒ³ãƒ†ãƒŠ */
        .glass-panel {
            background: var(--surface);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 1000px;
            padding: 32px;
            margin-bottom: 30px;
        }

        .btn-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }

        .btn {
            padding: 14px 24px;
            border-radius: 14px;
            font-weight: 800;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-decoration: none;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #06b6d4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #991b1b);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
            scale: 0.98;
        }

        /* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ»è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .section-box {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 18px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .section-title {
            font-size: 0.85rem;
            font-weight: 900;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-control {
            margin-bottom: 25px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .slider-label {
            font-weight: 700;
            color: var(--text-main);
            font-size: 0.95rem;
        }

        .slider-value {
            font-family: 'Outfit', sans-serif;
            font-weight: 800;
            color: var(--primary);
            background: rgba(14, 165, 233, 0.1);
            padding: 4px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            flex-grow: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #fff;
            border: 3px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary-glow);
            transition: all 0.2s;
        }

        /* çµ±è¨ˆãƒ»ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º */
        #statsDisplay {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 16px;
            border-radius: 100px;
            margin-bottom: 24px;
            display: inline-block;
        }

        /* ãƒãƒ£ãƒ¼ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 24px;
            width: 100%;
            max-width: 1200px;
        }

        .chart-card {
            background: var(--surface);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.3s ease;
        }

        .chart-card:hover {
            border-color: rgba(255, 255, 255, 0.2);
        }

        .chart-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-weight: 800;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            width: 100%;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 10px;
        }

        canvas {
            background: #020617;
            border-radius: 16px;
            width: 100% !important;
            height: auto !important;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #bowlCanvas {
            border-radius: 50%;
        }

        /* ã‚«ã‚¹ã‚¿ãƒ ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãƒ»é¸æŠè‚¢ */
        .check-item {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.03);
            padding: 12px 18px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.2s;
        }

        .check-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        select {
            background: rgba(15, 23, 42, 0.8);
            color: #fff;
            border: 1px solid var(--glass-border);
            padding: 10px 16px;
            border-radius: 12px;
            font-weight: 700;
            outline: none;
            width: 100%;
        }

        /* é–¾å€¤ãƒ»ã‚µãƒãƒªãƒ¼ */
        #thresholdDisplay {
            margin-top: 30px;
            padding: 24px;
            background: linear-gradient(135deg, rgba(244, 63, 94, 0.1), rgba(15, 23, 42, 0.4));
            border: 1px solid rgba(244, 63, 94, 0.3);
            border-radius: 20px;
            display: none;
        }

        .threshold-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin: 20px 0;
        }

        .threshold-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            text-align: center;
        }

        .threshold-item label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .threshold-item b {
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            color: #fff;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 32px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .threshold-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>

<body>
    <h1>Ride Quality Analytics</h1>

    <div id="statsDisplay">ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...</div>

    <div class="glass-panel">
        <div class="btn-group">
            <button id="syncBtn" class="btn btn-primary">
                <span>ğŸ”„</span> ã‚¯ãƒ©ã‚¦ãƒ‰åŒæœŸ
            </button>
            <button id="resetBtn" class="btn btn-danger">
                <span>ğŸ—‘ï¸</span> è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ
            </button>
            <a href="map.html" target="_blank" class="btn btn-success">
                <span>ğŸ—ºï¸</span> åœ°å›³ã§è©³ç´°è§£æ
            </a>
        </div>

        <div
            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; flex-wrap: wrap; gap: 15px;">
            <label class="check-item">
                <input type="checkbox" id="autoRefreshCheck" style="width: 18px; height: 18px;">
                <span style="font-weight: 700;">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦– (5ç§’æ¯)</span>
            </label>
        </div>

        <!-- åŸºæœ¬ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ -->
        <div class="section-box">
            <div class="section-title">ğŸ“‰ åŸºæœ¬ä¿¡å·å‡¦ç†</div>
            <div class="slider-control">
                <div class="slider-header">
                    <span class="slider-label">ãƒã‚¤ã‚ºé™¤å» (L-PASSå¼·åº¦)</span>
                    <span id="filterValueDisplay" class="slider-value">éå» 10 ã‚µãƒ³ãƒ—ãƒ«</span>
                </div>
                <div class="slider-container">
                    <span style="font-size: 0.75rem; color: var(--text-muted);">å¼±</span>
                    <input type="range" id="filterSlider" min="1" max="50" value="10">
                    <span style="font-size: 0.75rem; color: var(--text-muted);">å¼·</span>
                </div>
            </div>
        </div>

        <!-- é«˜åº¦ãªåˆ†æè¨­å®š -->
        <div class="section-box">
            <div class="section-title">ğŸ§­ åˆ†æãƒ»è¡¨ç¤ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è¨­å®š</div>

            <div style="display: flex; flex-direction: column; gap: 24px;">
                <!-- Zè»¸ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ -->
                <label class="check-item" style="border-left: 4px solid var(--road);">
                    <input type="checkbox" id="roadFilterCheck" checked style="width: 20px; height: 20px;">
                    <div style="display: flex; flex-direction: column;">
                        <span style="font-weight: 800; font-size: 1.05rem;">è·¯é¢è¦å› ã®è‡ªå‹•åˆ†é›¢ (Zè»¸ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼)</span>
                        <span
                            style="font-size: 0.8rem; color: var(--text-muted);">ç¸¦æºã‚Œã®å¼·ã„è¡æ’ƒã‚’æ¤œçŸ¥ã—ã€é‹è»¢æ“ä½œãƒŸã‚¹ã«ã‚ˆã‚‹ä¸å¿«æ„Ÿã‹ã‚‰è‡ªå‹•çš„ã«é™¤å¤–ã—ã¾ã™ã€‚</span>
                    </div>
                </label>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <!-- ã‚¹ã‚±ãƒ¼ãƒ«é¸æŠ -->
                    <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 16px;">
                        <label
                            style="display: block; font-size: 0.75rem; font-weight: 800; color: var(--text-muted); margin-bottom: 10px;">G-Bowl
                            æœ€å¤§ã‚¹ã‚±ãƒ¼ãƒ«</label>
                        <select id="gBowlMaxSelect">
                            <option value="0.20">0.20 G</option>
                            <option value="0.25">0.25 G</option>
                            <option value="0.30">0.30 G</option>
                            <option value="0.35">0.35 G</option>
                            <option value="0.40" selected>0.40 G</option>
                            <option value="0.45">0.45 G</option>
                            <option value="0.50">0.50 G</option>
                            <option value="0.60">0.60 G</option>
                            <option value="0.80">0.80 G</option>
                            <option value="1.00">1.00 G</option>
                        </select>
                    </div>

                    <!-- èµ°è¡Œé¸æŠ -->
                    <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 16px;">
                        <label
                            style="display: block; font-size: 0.75rem; font-weight: 800; color: var(--text-muted); margin-bottom: 10px;">è¡¨ç¤ºãƒ‡ãƒ¼ã‚¿ã®é¸æŠ</label>
                        <select id="runSelect">
                            <option value="all">ã™ã¹ã¦ã®èµ°è¡Œãƒ‡ãƒ¼ã‚¿ (å…¨ä½“åˆ†æ)</option>
                        </select>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <!-- Zè»¸é–¾å€¤ -->
                    <div class="slider-control"
                        style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 16px;">
                        <div class="slider-header">
                            <span class="slider-label" style="color: var(--road);">è·¯é¢åˆ¤å®šã®æ„Ÿåº¦ (Zè¡æ’ƒ)</span>
                            <span id="zThresholdValue" class="slider-value"
                                style="color: var(--road); background: rgba(245, 158, 11, 0.1);">0.80 G/s</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="zThresholdSlider" min="0.1" max="2.0" step="0.05" value="0.8">
                        </div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 10px; text-align: center;">
                            ä½ã„ã»ã©æ•æ„Ÿã«è·¯é¢ã¨ã—ã¦åˆ¤å®šã—ã¾ã™ã€‚</div>
                    </div>

                    <!-- åå¿œé…å»¶ -->
                    <div class="slider-control"
                        style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 16px;">
                        <div class="slider-header">
                            <span class="slider-label" style="color: var(--safe);">åå¿œé…å»¶ã®è£œæ­£ (é¡ã‚Š)</span>
                            <span id="lookbackValue" class="slider-value"
                                style="color: var(--safe); background: rgba(16, 185, 129, 0.1);">0.5 ç§’</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="lookbackSlider" min="0.0" max="3.0" step="0.1" value="0.5">
                        </div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 10px; text-align: center;">
                            ãƒœã‚¿ãƒ³æŠ¼ä¸‹ã‹ã‚‰æœ€å¤§ã§ã©ã‚Œã ã‘éå»ã®è¡æ’ƒã‚’æ‹¾ã†ã‹ã€‚</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="thresholdDisplay">
            <div class="section-title" style="color: var(--accent); justify-content: center;">ğŸš© è‡ªå‹•è§£æã«ã‚ˆã‚‹é‹è»¢é™ç•Œé–¾å€¤</div>
            <div class="threshold-grid" id="thresholdValues"></div>
            <div
                style="font-size: 0.75rem; color: var(--text-muted); text-align: center; border-top: 1px solid rgba(255,255,255,0.05); padding-top: 15px;">
                è·¯é¢èµ·å› ã‚’é™¤å¤–ã—ãŸã€ç´”ç²‹ãªã€Œæ“ä½œèµ·å› ã€ã®ç”³å‘Šãƒ‡ãƒ¼ã‚¿ä¸Šä½5%ã‚’çµ±è¨ˆçš„ã«é™¤å¤–ã—ãŸå®Ÿè³ªçš„ãªé™ç•Œå€¤ã§ã™ã€‚
            </div>
        </div>

        <div class="legend">
            <label class="check-item" style="padding: 8px 14px; font-size: 0.8rem;">
                <input type="checkbox" id="showSafeCheck" checked>
                <span class="dot" style="background: var(--safe); box-shadow: 0 0 10px var(--safe);"></span>å¿«é©
            </label>
            <label class="check-item" style="padding: 8px 14px; font-size: 0.8rem;">
                <input type="checkbox" id="showDriverCheck" checked>
                <span class="dot" style="background: var(--accent); box-shadow: 0 0 10px var(--accent);"></span>é‹è»¢è¦å› 
            </label>
            <label class="check-item" style="padding: 8px 14px; font-size: 0.8rem;">
                <input type="checkbox" id="showRoadCheck" checked>
                <span class="dot" style="background: var(--road); box-shadow: 0 0 10px var(--road);"></span>è·¯é¢è¦å› 
            </label>
            <div style="font-size: 0.8rem; display: flex; align-items: center; gap: 8px;">
                <span style="width: 20px; height: 1px; border-bottom: 2px dashed var(--accent);"></span> é™ç•Œå¢ƒç•Œç·š
            </div>
        </div>
    </div>

    <div class="charts-grid" id="chartsArea">
        <!-- æ•£å¸ƒå›³ -->
        <div class="chart-card" style="grid-column: 1 / -1; border-color: var(--primary-glow);">
            <div class="chart-label" style="color: var(--primary);">Impact Analysis: Road vs Driver (ä¸å¿«è¦å› åˆ†é›¢ãƒãƒˆãƒªã‚¯ã‚¹)</div>
            <canvas id="scatterCanvas" width="800" height="350"></canvas>
            <div
                style="display: flex; width: 100%; justify-content: space-between; font-size: 0.75rem; color: var(--text-muted); margin-top: 14px; padding: 0 40px;">
                <span>â† ç©ã‚„ã‹ãªæ“ä½œ</span>
                <span style="font-weight: 800; color: var(--text-main);">ä¸å¿«è¦å› ã®ç‰¹å®š</span>
                <span>æ¿€ã—ã„æ“ä½œ â†’</span>
            </div>
        </div>

        <div class="chart-card">
            <div class="chart-label">G-Bowl Distribution (å††é‹å‹•è¨ˆæ¸¬)</div>
            <canvas id="bowlCanvas" width="400" height="400"></canvas>
        </div>
        <div class="chart-card">
            <div class="chart-label">Impact Mapping (Jerk vs G)</div>
            <canvas id="jerkCanvas" width="500" height="400"></canvas>
        </div>
        <div class="chart-card">
            <div class="chart-label">Vertical G Timeline (ç¸¦æºã‚Œå±¥æ­´)</div>
            <canvas id="verticalCanvas" width="500" height="200"></canvas>
        </div>
        <div class="chart-card">
            <div class="chart-label">Tracking Path (èµ°è¡Œè»Œè·¡æ¨å®š)</div>
            <canvas id="pathCanvas" width="400" height="400"></canvas>
        </div>
    </div>

    <script>
        const bowlCtx = document.getElementById('bowlCanvas').getContext('2d');
        const jerkCtx = document.getElementById('jerkCanvas').getContext('2d');
        const verticalCtx = document.getElementById('verticalCanvas').getContext('2d');
        const pathCtx = document.getElementById('pathCanvas').getContext('2d');
        const scatterCtx = document.getElementById('scatterCanvas').getContext('2d');

        const filterSlider = document.getElementById('filterSlider');
        const filterValueDisplay = document.getElementById('filterValueDisplay');
        const roadFilterCheck = document.getElementById('roadFilterCheck');
        const gBowlMaxSelect = document.getElementById('gBowlMaxSelect');
        const zThresholdSlider = document.getElementById('zThresholdSlider');
        const zThresholdValue = document.getElementById('zThresholdValue');
        const lookbackSlider = document.getElementById('lookbackSlider');
        const lookbackValue = document.getElementById('lookbackValue');
        const runSelect = document.getElementById('runSelect');
        const showSafeCheck = document.getElementById('showSafeCheck');
        const showDriverCheck = document.getElementById('showDriverCheck');
        const showRoadCheck = document.getElementById('showRoadCheck');
        const thresholdDisplay = document.getElementById('thresholdDisplay');
        const thresholdValues = document.getElementById('thresholdValues');
        const syncBtn = document.getElementById('syncBtn');
        const autoRefreshCheck = document.getElementById('autoRefreshCheck');

        const gasUrl = "https://script.google.com/macros/s/AKfycbyza-BCowCNcWYb-63gx1gd4UARcYTeJ8DXqv-rrZwcRryWqfZanAnXfyrf6jFxMEfDIA/exec";

        let rawData = []; // All data fetched
        let currentTrips = []; // List of identified trips
        let wakeLock = null;
        let refreshInterval = null;

        const padding = 50; const pWidth = 400; const pHeight = 300;
        const sPadding = 60; const sWidth = 800 - sPadding * 2; const sHeight = 350 - sPadding * 2;
        const jMaxX = 1.0; const jMaxY = 0.5;
        const bCenter = 200;

        function drawGrids() {
            const gMax = parseFloat(gBowlMaxSelect.value);
            const bScale = 200 / gMax;

            // G-Bowl
            bowlCtx.clearRect(0, 0, 400, 400);
            bowlCtx.strokeStyle = '#1e293b'; bowlCtx.fillStyle = '#475569';
            bowlCtx.beginPath(); bowlCtx.moveTo(0, bCenter); bowlCtx.lineTo(400, bCenter);
            bowlCtx.moveTo(bCenter, 0); bowlCtx.lineTo(bCenter, 400); bowlCtx.stroke();

            bowlCtx.font = '10px sans-serif';
            let step = (gMax <= 0.3) ? 0.05 : 0.1;
            for (let g = step; g <= gMax; g += step) {
                bowlCtx.beginPath(); bowlCtx.arc(bCenter, bCenter, g * bScale, 0, Math.PI * 2); bowlCtx.stroke();
                bowlCtx.fillText(`${g.toFixed(2)}G`, bCenter + 5, bCenter - (g * bScale) + 12);
            }

            // Jerk
            jerkCtx.clearRect(0, 0, 500, 400); jerkCtx.fillStyle = '#0f172a'; jerkCtx.fillRect(0, 0, 500, 400);
            jerkCtx.strokeStyle = '#1e293b'; jerkCtx.beginPath();
            jerkCtx.moveTo(padding, padding); jerkCtx.lineTo(padding, 350); jerkCtx.lineTo(450, 350); jerkCtx.stroke();
            jerkCtx.fillStyle = '#475569'; jerkCtx.textAlign = 'center';
            for (let i = 0; i <= 10; i += 2) {
                let x = padding + (i / 10 / jMaxX) * pWidth;
                jerkCtx.fillText((i / 10).toFixed(1), x, 370);
            }
            jerkCtx.fillText('Jerk / åŠ åŠ åŠ é€Ÿåº¦ XYåˆç®— (G/s)', 250, 390);
            jerkCtx.textAlign = 'right'; jerkCtx.textBaseline = 'middle';
            for (let i = 0; i <= 5; i += 1) {
                let y = 350 - (i / 10 / jMaxY) * pHeight;
                jerkCtx.fillText((i / 10).toFixed(1), padding - 10, y);
            }

            // Vertical 
            verticalCtx.clearRect(0, 0, 500, 200); verticalCtx.strokeStyle = '#1e293b';
            verticalCtx.beginPath(); verticalCtx.moveTo(padding, 100); verticalCtx.lineTo(450, 100); verticalCtx.stroke();
            verticalCtx.fillStyle = '#475569'; verticalCtx.font = '10px sans-serif';
            verticalCtx.fillText('0G', padding - 5, 100);
            verticalCtx.fillText('+0.5G', padding - 5, 50);
            verticalCtx.fillText('-0.5G', padding - 5, 150);

            // Scatter
            scatterCtx.clearRect(0, 0, 800, 350);
            scatterCtx.strokeStyle = '#1e293b'; scatterCtx.fillStyle = '#475569';
            scatterCtx.beginPath();
            scatterCtx.moveTo(sPadding, sPadding);
            scatterCtx.lineTo(sPadding, 350 - sPadding); // Y axis
            scatterCtx.lineTo(800 - sPadding, 350 - sPadding); // X axis
            scatterCtx.stroke();
            scatterCtx.textAlign = 'center'; scatterCtx.textBaseline = 'top';
            scatterCtx.fillText('é‹è»¢è¦å›  [ XYè»¸ åˆæˆG + Jerkå€¤ ]', 400, 350 - sPadding + 15);

            scatterCtx.save();
            scatterCtx.translate(sPadding - 25, 175);
            scatterCtx.rotate(-Math.PI / 2);
            scatterCtx.textAlign = 'center';
            scatterCtx.fillText('è·¯é¢è¦å›  [ Zè»¸ Jerkè¡æ’ƒ ]', 0, 0);
            scatterCtx.restore();

            // Path Grid
            pathCtx.clearRect(0, 0, 400, 400); pathCtx.strokeStyle = '#1e293b';
            pathCtx.beginPath(); pathCtx.moveTo(0, 200); pathCtx.lineTo(400, 200);
            pathCtx.moveTo(200, 0); pathCtx.lineTo(200, 400); pathCtx.stroke();
        }

        function processAndPlot() {
            if (rawData.length === 0) { drawGrids(); return; }

            // Filter data based on selected trip
            const selectedTripId = runSelect.value;
            let displayData = rawData;
            if (selectedTripId !== 'all') {
                const trip = currentTrips.find(t => t.id === selectedTripId);
                if (trip) {
                    displayData = rawData.slice(trip.startIndex, trip.endIndex + 1);
                }
            }

            if (displayData.length === 0) { drawGrids(); return; }

            const windowSize = parseInt(filterSlider.value);
            filterValueDisplay.innerText = `ç¾åœ¨ã®è¨­å®š: éå» ${windowSize} ã‚µãƒ³ãƒ—ãƒ« (ç´„ ${(windowSize * 0.05).toFixed(2)} ç§’)`;

            const gMax = parseFloat(gBowlMaxSelect.value);
            const bScale = 200 / gMax;
            drawGrids();

            let processedData = [];
            for (let i = 0; i < displayData.length; i++) {
                let sumX = 0; let sumY = 0; let count = 0;
                for (let j = Math.max(0, i - windowSize + 1); j <= i; j++) {
                    sumX += displayData[j].rawX; sumY += displayData[j].rawY; count++;
                }

                let smoothX = sumX / count; let smoothY = sumY / count;
                processedData.push({
                    time: displayData[i].time,
                    uncomf: displayData[i].uncomf,
                    sX: smoothX, sY: smoothY,
                    rawZ: displayData[i].rawZ,
                    jerkZ: displayData[i].jerkZ,
                    sG: Math.sqrt(smoothX ** 2 + smoothY ** 2),
                    jerk: displayData[i].jerk || 0,
                    yaw: displayData[i].yaw || 0,
                    lat: displayData[i].lat, lon: displayData[i].lon
                });
            }

            for (let i = 1; i < processedData.length; i++) {
                if (processedData[i].jerk === 0) {
                    let dt = (processedData[i].time - processedData[i - 1].time) / 1000;
                    if (dt > 0) processedData[i].jerk = Math.abs((processedData[i].sG - processedData[i - 1].sG) / dt);
                }
            }

            const getJX = (j) => padding + (Math.min(j, jMaxX) / jMaxX) * pWidth;
            const getJY = (g) => 350 - (Math.min(g, jMaxY) / jMaxY) * pHeight;

            // Scatter max limits for scaling
            const scMaxX = 1.5; // (XY Jerk + XY G*2) max expectation
            const scMaxY = 3.0; // Z Jerk max expectation
            const getScX = (drvFactor) => sPadding + (Math.min(drvFactor, scMaxX) / scMaxX) * sWidth;
            const getScY = (roadFactor) => (350 - sPadding) - (Math.min(roadFactor, scMaxY) / scMaxY) * sHeight;

            let safeC = 0, dangerC = 0, roadC = 0;
            const useRoadFilter = roadFilterCheck.checked;
            const zThresh = parseFloat(zThresholdSlider.value);
            zThresholdValue.innerText = zThresh.toFixed(2) + " G/s";
            const lookbackTime = parseFloat(lookbackSlider.value);
            lookbackValue.innerText = lookbackTime.toFixed(1) + " ç§’";

            const showSafe = showSafeCheck.checked;
            const showDriver = showDriverCheck.checked;
            const showRoad = showRoadCheck.checked;

            // Draw Lines for Vertical G and Path
            verticalCtx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
            pathCtx.strokeStyle = 'rgba(76, 175, 80, 0.8)';
            verticalCtx.beginPath(); pathCtx.beginPath();
            processedData.forEach((p, idx) => {
                let vx = padding + (idx / processedData.length) * pWidth;
                let vy = 100 - (p.rawZ * 100);
                if (idx === 0) verticalCtx.moveTo(vx, vy); else verticalCtx.lineTo(vx, vy);

                let px = 200 + Math.sin(p.yaw) * (idx * 0.5);
                let py = 200 - Math.cos(p.yaw) * (idx * 0.5);
                if (idx === 0) pathCtx.moveTo(px, py); else pathCtx.lineTo(px, py);
            });
            verticalCtx.stroke(); pathCtx.stroke();

            // Safe Points
            if (showSafe) {
                bowlCtx.fillStyle = 'rgba(76, 175, 80, 0.15)';
                jerkCtx.fillStyle = 'rgba(76, 175, 80, 0.15)';
                processedData.forEach(p => {
                    if (p.uncomf === 0) {
                        bowlCtx.beginPath(); bowlCtx.arc(bCenter + (p.sX * bScale), bCenter - (p.sY * bScale), 2, 0, Math.PI * 2); bowlCtx.fill();
                        jerkCtx.beginPath(); jerkCtx.arc(getJX(p.jerk), getJY(p.sG), 2, 0, Math.PI * 2); jerkCtx.fill();
                    }
                });
            }
            processedData.forEach(p => { if (p.uncomf === 0) safeC++; });

            // Danger Points mapping
            let driverDangerPoints = [];

            processedData.forEach((p, idx) => {
                if (p.uncomf === 1) {
                    let isRoad = false;
                    let evalZJerk = Math.abs(p.jerkZ);

                    // ãƒ«ãƒƒã‚¯ãƒãƒƒã‚¯ï¼šè¨­å®šã•ã‚ŒãŸç§’æ•°ï¼ˆãƒŸãƒªç§’ï¼‰ã ã‘éå»ã«é¡ã£ã¦æœ€å¤§ã®Zè¡æ’ƒã‚’æ¢ã™
                    if (useRoadFilter && lookbackTime > 0) {
                        let lookbackMs = lookbackTime * 1000;
                        for (let j = idx; j >= 0; j--) {
                            if (p.time - processedData[j].time > lookbackMs) break;
                            let absZ = Math.abs(processedData[j].jerkZ);
                            if (absZ > evalZJerk) evalZJerk = absZ;
                        }
                    }

                    // è·¯é¢ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãŒONã€ã‹ã¤Zè»¸ã®è¡æ’ƒãŒè¨­å®šé–¾å€¤ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆ
                    if (useRoadFilter && evalZJerk > zThresh) {
                        isRoad = true;
                        roadC++;
                    } else {
                        driverDangerPoints.push(p);
                        dangerC++;
                    }

                    // Bowl & Jerk Plots
                    if ((isRoad && showRoad) || (!isRoad && showDriver)) {
                        if (isRoad) {
                            bowlCtx.fillStyle = 'rgba(251, 140, 0, 0.8)'; // Orange
                            jerkCtx.fillStyle = 'rgba(251, 140, 0, 0.8)';
                        } else {
                            bowlCtx.fillStyle = 'rgba(244, 67, 54, 0.8)'; // Red
                            jerkCtx.fillStyle = 'rgba(244, 67, 54, 0.8)';
                        }
                        bowlCtx.beginPath(); bowlCtx.arc(bCenter + (p.sX * bScale), bCenter - (p.sY * bScale), 3, 0, Math.PI * 2); bowlCtx.fill();
                        jerkCtx.beginPath(); jerkCtx.arc(getJX(p.jerk), getJY(p.sG), 3, 0, Math.PI * 2); jerkCtx.fill();

                        // Scatter Plot Mapping
                        let drvFactor = p.sG * 2.0 + p.jerk;
                        let roadFactor = evalZJerk;
                        scatterCtx.fillStyle = isRoad ? 'rgba(251, 140, 0, 0.8)' : 'rgba(244, 67, 54, 0.8)';
                        scatterCtx.beginPath();
                        scatterCtx.arc(getScX(drvFactor), getScY(roadFactor), 4, 0, Math.PI * 2);
                        scatterCtx.fill();

                        // Overlay on Vertical Canvas
                        let vx = padding + (idx / processedData.length) * pWidth;
                        verticalCtx.fillStyle = isRoad ? 'rgba(251, 140, 0, 1)' : 'rgba(244, 67, 54, 1)';
                        verticalCtx.beginPath();
                        verticalCtx.arc(vx, 100 - (p.rawZ * 100), 4, 0, Math.PI * 2);
                        verticalCtx.fill();
                    }
                }
            });

            // Calculate Thresholds based ONLY on Driver Danger Points
            if (driverDangerPoints.length >= 20) {
                let p5Index = Math.floor(driverDangerPoints.length * 0.05); // Top 95%
                let sortedAbsGx = driverDangerPoints.map(p => Math.abs(p.sX)).sort((a, b) => a - b);
                let sortedAbsGy = driverDangerPoints.map(p => Math.abs(p.sY)).sort((a, b) => a - b);
                let sortedJerk = driverDangerPoints.map(p => p.jerk).sort((a, b) => a - b);
                let sortedG = driverDangerPoints.map(p => p.sG).sort((a, b) => a - b);

                let threshGx = sortedAbsGx[p5Index]; let threshGy = sortedAbsGy[p5Index];
                let threshJerk = sortedJerk[p5Index]; let threshG = sortedG[p5Index];

                // Draw Threshold Ellipse on Bowl
                bowlCtx.beginPath();
                if (typeof bowlCtx.ellipse === 'function') {
                    bowlCtx.ellipse(bCenter, bCenter, threshGx * bScale, threshGy * bScale, 0, 0, Math.PI * 2);
                } else {
                    bowlCtx.arc(bCenter, bCenter, Math.max(threshGx, threshGy) * bScale, 0, Math.PI * 2);
                }
                bowlCtx.strokeStyle = 'rgba(255, 59, 48, 0.8)'; bowlCtx.lineWidth = 2;
                bowlCtx.setLineDash([5, 5]); bowlCtx.stroke(); bowlCtx.setLineDash([]);

                // Draw Threshold lines on Jerk Canvas
                jerkCtx.strokeStyle = 'rgba(255, 59, 48, 0.8)'; jerkCtx.lineWidth = 2; jerkCtx.setLineDash([5, 5]);
                let tJx = getJX(threshJerk); jerkCtx.beginPath(); jerkCtx.moveTo(tJx, padding); jerkCtx.lineTo(tJx, 350); jerkCtx.stroke();
                let tGy = getJY(threshG); jerkCtx.beginPath(); jerkCtx.moveTo(padding, tGy); jerkCtx.lineTo(450, tGy); jerkCtx.stroke();
                jerkCtx.setLineDash([]);
                jerkCtx.fillStyle = 'rgba(244, 67, 54, 0.08)';
                jerkCtx.fillRect(tJx, padding, 450 - tJx, tGy - padding);

                thresholdDisplay.style.display = 'block';
                thresholdValues.innerHTML = `
                    <div class="threshold-item"><label>å·¦å³æ—‹å› G</label><b>${threshGx.toFixed(2)} G</b></div>
                    <div class="threshold-item"><label>å‰å¾ŒåŠ æ¸›é€Ÿ G</label><b>${threshGy.toFixed(2)} G</b></div>
                    <div class="threshold-item"><label>ã‚¸ãƒ£ãƒ¼ã‚¯ (è¡æ’ƒåº¦)</label><b>${threshJerk.toFixed(2)} G/s</b></div>
                    <div class="threshold-item"><label>ãƒˆãƒ¼ã‚¿ãƒ«åˆæˆ G</label><b>${threshG.toFixed(2)} G</b></div>
                `;
            } else {
                thresholdDisplay.style.display = 'none';
                if (dangerC > 0 && dangerC < 20) {
                    document.getElementById('statsDisplay').innerText += " | â€»åˆ†æç²¾åº¦å‘ä¸Šã®ãŸã‚æ“ä½œèµ·å› ãƒ‡ãƒ¼ã‚¿ãŒ20ä»¶ä»¥ä¸Šå¿…è¦ã§ã™";
                }
            }

            let msg = `ğŸ›°ï¸ åˆ†æå¯¾è±¡: ${processedData.length}ä»¶ | ğŸ˜Š å¿«é©: ${safeC}ä»¶ | âš ï¸ é‹è»¢è¦å› : ${dangerC}ä»¶`;
            if (useRoadFilter) msg += ` | ğŸš§ è·¯é¢è¦å› : ${roadC}ä»¶`;
            document.getElementById('statsDisplay').innerText = msg;
        }

        async function syncFromCloud(isAuto) {
            if (!isAuto) {
                document.getElementById('statsDisplay').innerText = "â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...";
                syncBtn.disabled = true;
            }
            try {
                const response = await fetch(gasUrl + "?t=" + Date.now());
                if (!response.ok) throw new Error("Server response was " + response.status);

                const data = await response.json();
                if (data && data.length > 0) {
                    rawData = data.map(row => ({
                        time: parseInt(row.time_ms), uncomf: parseInt(row.uncomfortable),
                        rawX: parseFloat(row.rawG_X), rawY: parseFloat(row.rawG_Y), rawZ: parseFloat(row.rawG_Z || 0),
                        jerkZ: parseFloat(row.jerk_Z || 0),
                        jerk: Math.sqrt(parseFloat(row.jerk_X || 0) ** 2 + parseFloat(row.jerk_Y || 0) ** 2),
                        yaw: parseFloat(row.yaw_rad || 0), lat: parseFloat(row.lat || 0), lon: parseFloat(row.lon || 0),
                        age: row.age || 0, exp: row.exp || 0
                    }));
                    rawData.sort((a, b) => a.time - b.time);

                    // Group into Trips based on time gaps (> 1 minute)
                    const GAP_THRESHOLD_MS = 60000;
                    currentTrips = [];
                    if (rawData.length > 0) {
                        let tripStartIdx = 0;
                        for (let i = 1; i < rawData.length; i++) {
                            if (rawData[i].time - rawData[i - 1].time > GAP_THRESHOLD_MS) {
                                // Close current trip
                                currentTrips.push({
                                    id: `trip_${tripStartIdx}`,
                                    startIndex: tripStartIdx,
                                    endIndex: i - 1,
                                    startTime: rawData[tripStartIdx].time,
                                    age: rawData[tripStartIdx].age,
                                    exp: rawData[tripStartIdx].exp
                                });
                                tripStartIdx = i;
                            }
                        }
                        // Add last trip
                        currentTrips.push({
                            id: `trip_${tripStartIdx}`,
                            startIndex: tripStartIdx,
                            endIndex: rawData.length - 1,
                            startTime: rawData[tripStartIdx].time,
                            age: rawData[tripStartIdx].age,
                            exp: rawData[tripStartIdx].exp
                        });
                    }

                    // Update Selector UI
                    const previousSelection = runSelect.value;
                    runSelect.innerHTML = '<option value="all">ã™ã¹ã¦ã®èµ°è¡Œãƒ‡ãƒ¼ã‚¿ (å…¨ä½“ã‚’è¡¨ç¤º)</option>';
                    currentTrips.forEach((t, i) => {
                        const date = new Date(t.startTime);
                        const timeStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}`;
                        const label = `${i + 1}ï¼š${t.age}æ­³/æ­´${t.exp}å¹´ (${timeStr}ã€œ)`;
                        const opt = document.createElement("option");
                        opt.value = t.id;
                        opt.textContent = label;
                        runSelect.appendChild(opt);
                    });
                    if ([...runSelect.options].some(o => o.value === previousSelection)) {
                        runSelect.value = previousSelection;
                    }

                    processAndPlot();
                    if (!isAuto) document.getElementById('statsDisplay').innerText = "âœ¨ åŒæœŸå®Œäº† (" + rawData.length + "ä»¶ã‚’å–å¾—)";
                } else {
                    if (!isAuto) document.getElementById('statsDisplay').innerText = "âš ï¸ ãƒ‡ãƒ¼ã‚¿ãŒå±Šã„ã¦ã„ãªã„ã‚ˆã†ã§ã™";
                    rawData = []; processAndPlot();
                }
            } catch (e) {
                console.error(e);
                if (!isAuto) document.getElementById('statsDisplay').innerText = "âŒ åŒæœŸå¤±æ•—: " + e.message;
            } finally {
                if (!isAuto) syncBtn.disabled = false;
            }
        }

        // Event Listeners
        autoRefreshCheck.addEventListener('change', () => {
            if (autoRefreshCheck.checked) {
                syncFromCloud(true);
                refreshInterval = setInterval(() => syncFromCloud(true), 5000);
            } else {
                clearInterval(refreshInterval);
            }
        });

        syncBtn.addEventListener('click', () => syncFromCloud(false));
        filterSlider.addEventListener('input', processAndPlot);
        roadFilterCheck.addEventListener('change', processAndPlot);
        gBowlMaxSelect.addEventListener('change', processAndPlot);
        zThresholdSlider.addEventListener('input', processAndPlot);
        lookbackSlider.addEventListener('input', processAndPlot);
        runSelect.addEventListener('change', processAndPlot);
        showSafeCheck.addEventListener('change', processAndPlot);
        showDriverCheck.addEventListener('change', processAndPlot);
        showRoadCheck.addEventListener('change', processAndPlot);

        document.getElementById('resetBtn').addEventListener('click', async () => {
            const pass = prompt("ãƒ‡ãƒ¼ã‚¿ãƒªã‚»ãƒƒãƒˆç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (7710)");
            if (!pass || pass !== '7710') { if (pass) alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™"); return; }
            if (!confirm("æœ¬å½“ã«ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n(ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®å…¨è¡ŒãŒæ¶ˆå»ã•ã‚Œã¾ã™)")) return;
            try {
                await fetch(gasUrl, { method: 'POST', mode: 'no-cors', cache: 'no-cache', body: JSON.stringify({ action: 'reset', password: pass }) });
                alert("ãƒªã‚»ãƒƒãƒˆå‘½ä»¤ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚1ã€œ2ç§’å¾…ã£ã¦ã‹ã‚‰åŒæœŸãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚");
                rawData = []; processAndPlot();
            } catch (e) { alert("ãƒªã‚»ãƒƒãƒˆå¤±æ•—: " + e.message); }
        });

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) { console.error(`${err.name}, ${err.message}`); }
        }

        window.addEventListener('load', async () => {
            await requestWakeLock();
            drawGrids();
            syncFromCloud(false);
        });

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') await requestWakeLock();
        });

        document.addEventListener('touchstart', requestWakeLock, { once: true });
    </script>
</body>

</html>